<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>Mystery Tarot Ritual</title>
<style>
    body { margin: 0; overflow: hidden; background: #000; color: #d4af37; font-family: 'Palatino', serif; }
    #canvas-container { width: 100vw; height: 100vh; }
    #ui-overlay { position: absolute; top: 40px; width: 100%; text-align: center; pointer-events: none; z-index: 10; }
    .hint { font-size: 1.8rem; text-shadow: 0 0 15px #d4af37; opacity: 0.9; }
    #interpretation { 
        position: absolute; bottom: 120px; width: 80%; left: 10%; 
        text-align: center; font-size: 1.2rem; line-height: 1.6;
        background: rgba(5, 5, 10, 0.7); padding: 20px; border-radius: 15px;
        border: 1px solid #d4af37; display: none;
    }
    #loading { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: #05050a; z-index: 100; }
    video { transform: scaleX(-1); position: absolute; bottom: 10px; right: 10px; width: 180px; border: 1px solid #d4af37; border-radius: 8px; opacity: 0.5; }
</style>
</head>
<body>

<div id="loading">正在开启命运之门...</div>
<div id="ui-overlay">
    <div class="hint" id="status-text">握紧拳头 唤醒塔罗</div>
</div>
<div id="interpretation" id="inter-text"></div>

<video id="webcam" autoplay playsinline></video>
<div id="canvas-container"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
let scene, camera, renderer, particles;
let cards = [];
let selectedCards = [];
let currentState = 'IDLE'; // IDLE, SHUFFLE, DRAWING, FINISHED
let lastSelectTime = 0;
let hasSeenHand = false;

// 音效逻辑
const drawSound = new Audio('https://assets.mixkit.co/active_storage/sfx/2571/2571-preview.mp3'); 
const flipSound = new Audio('https://assets.mixkit.co/active_storage/sfx/2017/2017-preview.mp3');

/* 78张牌数据与简易解析词库 */
const majorArcana = ["愚者","魔术师","女教皇","女皇","皇帝","教皇","恋人","战车","正义","隐士","命运之轮","力量","倒吊人","死神","节制","恶魔","塔","星星","月亮","太阳","审判","世界"];
const suits = ["权杖","圣杯","宝剑","星币"];
const ranks = ["ACE","2","3","4","5","6","7","8","9","10","侍从","骑士","王后","国王"];
const cardData = [...majorArcana];
suits.forEach(s => ranks.forEach(r => cardData.push(`${s}${r}`)));

const meanings = {
    "愚者": "新的开始，冒险与无限可能。", "魔术师": "行动力，创造力与潜能的觉醒。",
    "女教皇": "直觉，智慧与内心的平静。", "死神": "结束即是新生，深刻的转化。",
    "权杖": "行动与能量的象征。", "圣杯": "情感与人际关系的波动。",
    "宝剑": "思想、挑战与决断力。", "星币": "物质积累与现实的稳固。"
};

function initScene() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x05050a, 0.1);
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 12;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const light = new THREE.PointLight(0xd4af37, 2, 50);
    light.position.set(0, 10, 10);
    scene.add(light);

    createCards();
    createGlobalParticles();
    animate();
}

function createCardTexture(text, isBack = false) {
    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 400;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = isBack ? '#1a1a2e' : '#fdfbf0';
    ctx.fillRect(0, 0, 256, 400);
    ctx.strokeStyle = '#d4af37'; ctx.lineWidth = 15;
    ctx.strokeRect(10, 10, 236, 380);
    if (!isBack) {
        ctx.fillStyle = '#1a1a2e'; ctx.font = 'bold 30px STKaiti';
        ctx.textAlign = 'center'; ctx.fillText(text, 128, 200);
    }
    return new THREE.CanvasTexture(canvas);
}

function createCards() {
    const geo = new THREE.BoxGeometry(2, 3.2, 0.05);
    const backTex = createCardTexture("", true);
    cardData.forEach((name, i) => {
        const frontTex = createCardTexture(name);
        const mats = [
            new THREE.MeshStandardMaterial({color:0x222}), new THREE.MeshStandardMaterial({color:0x222}),
            new THREE.MeshStandardMaterial({color:0x222}), new THREE.MeshStandardMaterial({color:0x222}),
            new THREE.MeshStandardMaterial({map:frontTex}), new THREE.MeshStandardMaterial({map:backTex})
        ];
        const card = new THREE.Mesh(geo, mats);
        card.position.set(Math.random()*20-10, -15, Math.random()*-10);
        card.userData = { name, originalIndex: i, phase: Math.random() * Math.PI * 2 };
        scene.add(card);
        cards.push(card);
    });
}

function createGlobalParticles() {
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(2000 * 3);
    for(let i=0; i<6000; i++) pos[i] = (Math.random()-0.5) * 40;
    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const mat = new THREE.PointsMaterial({ color: 0xd4af37, size: 0.05, transparent: true, opacity: 0.5 });
    particles = new THREE.Points(geo, mat);
    scene.add(particles);
}

/* 状态切换：进入洗牌阶段 */
function startShuffle() {
    if (currentState !== 'IDLE') return;
    currentState = 'SHUFFLE';
    document.getElementById('status-text').innerText = "仪式开始：请伸出单指抽取";
}

/* 抽牌逻辑 */
function drawOneCard() {
    const now = Date.now();
    if (currentState !== 'SHUFFLE' || selectedCards.length >= 3 || now - lastSelectTime < 2000) return;
    lastSelectTime = now;
    drawSound.play();

    const available = cards.filter(c => !selectedCards.includes(c));
    const card = available[Math.floor(Math.random() * available.length)];
    selectedCards.push(card);

    // 其他卡牌淡化
    cards.forEach(c => {
        if (!selectedCards.includes(c)) {
            gsap.to(c.scale, { x: 0.5, y: 0.5, z: 0.5, duration: 1 });
            c.material.forEach(m => { m.transparent = true; gsap.to(m, { opacity: 0.3, duration: 1 }); });
        }
    });

    // 选中卡牌飞向中央并放大
    gsap.to(card.position, { x: 0, y: 0, z: 6, duration: 1.5, ease: "power2.inOut" });
    gsap.to(card.rotation, { x: 0, y: 0, z: 0, duration: 1.5 });
    gsap.to(card.scale, { x: 1.5, y: 1.5, z: 1.5, duration: 1.5 });

    if (selectedCards.length === 3) {
        currentState = 'WAIT_REVEAL';
        setTimeout(revealAll, 1500);
    } else {
        // 1秒后将抽到的牌移到旁边位置，准备抽下一张
        setTimeout(() => {
            gsap.to(card.position, { x: (selectedCards.length - 2) * 3.5, y: 1, z: 4, duration: 1 });
            gsap.to(card.scale, { x: 1, y: 1, z: 1, duration: 1 });
        }, 1200);
    }
}

function revealAll() {
    currentState = 'FINISHED';
    flipSound.play();
    let interpretationText = "命运的启示：<br>";
    
    selectedCards.forEach((card, i) => {
        gsap.to(card.rotation, { y: Math.PI, duration: 1.5, delay: i * 0.4 });
        const name = card.userData.name;
        const hint = meanings[name] || meanings[name.substring(0,2)] || "未知的契机。";
        interpretationText += `【${name}】: ${hint} `;
    });

    setTimeout(() => {
        const ui = document.getElementById('interpretation');
        ui.innerHTML = interpretationText;
        ui.style.display = 'block';
        gsap.from(ui, { opacity: 0, y: 20, duration: 1 });
    }, 2000);
}

/* 核心动画循环 */
function animate() {
    requestAnimationFrame(animate);
    const time = Date.now() * 0.001;

    if (currentState === 'SHUFFLE') {
        cards.forEach((c, i) => {
            if (!selectedCards.includes(c)) {
                const angle = (i / cards.length) * Math.PI * 2 + time * 0.5;
                c.position.x = Math.cos(angle) * 8;
                c.position.y = Math.sin(angle) * 5 + Math.sin(time + c.userData.phase) * 0.5;
                c.position.z = Math.sin(angle) * 2;
                c.rotation.y = angle + Math.PI/2;
            }
        });
    }

    if (particles) {
        particles.rotation.y += 0.001;
        particles.position.y = Math.sin(time) * 0.5;
    }

    renderer.render(scene, camera);
}

/* 手势识别 */
const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.8 });
hands.onResults(res => {
    if (!res.multiHandLandmarks || res.multiHandLandmarks.length === 0) return;
    if (!hasSeenHand) { document.getElementById('loading').remove(); hasSeenHand = true; }

    const lm = res.multiHandLandmarks[0];
    const isFist = lm[8].y > lm[6].y && lm[12].y > lm[10].y && lm[16].y > lm[14].y;
    const isPoint = lm[8].y < lm[6].y && lm[12].y > lm[10].y && lm[16].y > lm[14].y;

    if (isFist && currentState === 'IDLE') startShuffle();
    if (isPoint && currentState === 'SHUFFLE') drawOneCard();
});

const cam = new Camera(document.getElementById('webcam'), {
    onFrame: async () => { await hands.send({ image: document.getElementById('webcam') }); },
    width: 480, height: 270
});
cam.start();

initScene();
</script>
</body>
</html>
