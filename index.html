<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>Mystery Tarot</title>

<style>
body {
    margin: 0;
    overflow: hidden;
    background: #05050a;
    color: #d4af37;
    font-family: 'Palatino', serif;
}

#canvas-container {
    width: 100vw;
    height: 100vh;
}

#ui-overlay {
    position: absolute;
    top: 20px;
    width: 100%;
    text-align: center;
    pointer-events: none;
}

.hint {
    font-size: 1.5rem;
    text-shadow: 0 0 10px #d4af37;
    opacity: 0.85;
}

#loading {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #05050a;
    z-index: 100;
    font-size: 1.2rem;
}

video {
    transform: scaleX(-1);
    position: absolute;
    bottom: 10px;
    right: 10px;
    width: 200px;
    border: 2px solid #d4af37;
    border-radius: 8px;
}
</style>
</head>

<body>

<div id="loading">正在初始化塔罗仪式...</div>

<div id="ui-overlay">
    <div class="hint" id="status-text">请握紧拳头开始</div>
</div>

<video id="webcam" autoplay playsinline></video>
<div id="canvas-container"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* =====================
   Three.js 基础
===================== */
let scene, camera, renderer;
let cards = [];
let selectedCards = [];
let currentState = 'IDLE';
let lastSelectTime = 0;
let hasSeenHand = false;

/* =====================
   78 张牌数据
===================== */
const majorArcana = [
    "愚者","魔术师","女教皇","女皇","皇帝","教皇","恋人","战车",
    "正义","隐士","命运之轮","力量","倒吊人","死神","节制","恶魔",
    "塔","星星","月亮","太阳","审判","世界"
];
const suits = ["权杖","圣杯","宝剑","星币"];
const ranks = ["ACE","2","3","4","5","6","7","8","9","10","侍从","骑士","王后","国王"];
const cardData = [...majorArcana];
suits.forEach(s => ranks.forEach(r => cardData.push(`${s}${r}`)));

/* =====================
   Canvas 卡牌纹理
===================== */
function createCardTexture(text, back=false) {
    const c = document.createElement('canvas');
    c.width = 256; c.height = 400;
    const ctx = c.getContext('2d');

    ctx.fillStyle = back ? '#1a1a2e' : '#fdfbf0';
    ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle = '#d4af37';
    ctx.lineWidth = 12;
    ctx.strokeRect(10,10,c.width-20,c.height-20);

    if (!back) {
        ctx.fillStyle = '#1a1a2e';
        ctx.font = 'bold 28px Palatino';
        ctx.textAlign = 'center';
        ctx.fillText(text, c.width/2, c.height/2);
    }

    return new THREE.CanvasTexture(c);
}

/* =====================
   初始化 Three.js
===================== */
function initScene() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x05050a, 0.12);

    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.z = 10;

    renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff,0.6));
    const light = new THREE.PointLight(0xd4af37,2,50);
    light.position.set(0,5,5);
    scene.add(light);

    createCards();
    animate();
}

function createCards() {
    const geo = new THREE.BoxGeometry(2,3.2,0.05);
    const back = createCardTexture("", true);

    cardData.forEach(name => {
        const front = createCardTexture(name);
        const mats = [
            new THREE.MeshStandardMaterial({color:0x333333}),
            new THREE.MeshStandardMaterial({color:0x333333}),
            new THREE.MeshStandardMaterial({color:0x333333}),
            new THREE.MeshStandardMaterial({color:0x333333}),
            new THREE.MeshStandardMaterial({map:front}),
            new THREE.MeshStandardMaterial({map:back})
        ];
        const card = new THREE.Mesh(geo, mats);
        card.position.y = -12;
        scene.add(card);
        cards.push(card);
    });
}

/* =====================
   交互
===================== */
function spreadCards() {
    if (currentState !== 'IDLE') return;
    currentState = 'FAN';
    document.getElementById('status-text').innerText = "伸出食指 抽取三张牌";

    cards.forEach((c,i)=>{
        const a = (i/cards.length)*Math.PI*1.5 - Math.PI*0.75;
        gsap.to(c.position,{
            x:Math.sin(a)*7,
            y:Math.cos(a)*-2,
            z:i*0.01,
            duration:1.8,
            ease:"expo.out"
        });
        gsap.to(c.rotation,{z:-a,duration:1.8});
    });
}

function selectOneCard() {
    const now = Date.now();
    if (currentState!=='FAN' || selectedCards.length>=3 || now-lastSelectTime<1500) return;
    lastSelectTime = now;

    const pool = cards.filter(c=>!selectedCards.includes(c));
    const card = pool[Math.floor(Math.random()*pool.length)];
    selectedCards.push(card);

    gsap.to(card.position,{
        x:(selectedCards.length-2)*2.8,
        y:1.5,z:4,duration:1.2,ease:"back.out(1.6)"
    });
    gsap.to(card.rotation,{x:0,y:0,z:0,duration:1.2});

    if (selectedCards.length===3) {
        currentState='FINISHED';
        setTimeout(revealCards,1000);
    }
}

function revealCards() {
    document.getElementById('status-text').innerText="命运已定…";
    selectedCards.forEach((c,i)=>{
        gsap.to(c.rotation,{y:Math.PI,duration:1.5,delay:i*0.4});
    });
}

/* =====================
   MediaPipe Hands
===================== */
const hands = new Hands({
    locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});
hands.setOptions({
    maxNumHands:1,
    modelComplexity:1,
    minDetectionConfidence:0.7,
    minTrackingConfidence:0.7
});

hands.onResults(res=>{
    if (!res.multiHandLandmarks) return;

    if (!hasSeenHand) {
        document.getElementById('loading')?.remove();
        hasSeenHand=true;
    }

    const lm = res.multiHandLandmarks[0];
    const isFist = lm[8].y>lm[6].y && lm[12].y>lm[10].y && lm[16].y>lm[14].y;
    const isPoint = lm[8].y<lm[6].y && lm[12].y>lm[10].y;

    if (isFist && currentState==='IDLE') spreadCards();
    if (isPoint && currentState==='FAN') selectOneCard();
});

/* =====================
   摄像头
===================== */
const video = document.getElementById('webcam');
const cam = new Camera(video,{
    onFrame: async ()=>{ await hands.send({image:video}); },
    width:480,height:270
});
cam.start();

/* =====================
   渲染循环
===================== */
function animate(){
    requestAnimationFrame(animate);
    renderer.render(scene,camera);
}

initScene();
</script>

</body>
</html>